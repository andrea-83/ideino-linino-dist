/***
 * file: gpio.js
 * author: https://github.com/quasto
 * based on: https://github.com/fivdi/onoff/blob/master/onoff.js 
 ***/

var fs = require('fs'),
    pwmRootPath = '/sys/class/mcuio_pwm/',
	values = [];
	
var StringDecoder = require('string_decoder').StringDecoder;
var decoder = new StringDecoder('utf8');

exports.version = '0.0.1';

function Pwm(map, options) {
    var valuePath; // contiene il path al value della gpio
	
	options = options || {};
	
    this.map = map;
    this.pwmPath = pwmRootPath + this.map + '/';
    this.opts = {};
    this.opts.debounceTimeout = options.debounceTimeout || 0;
    this.sampling = options.sampling || 25;
	this.resolution = options.resolution || 40;
	this.bit =  options.bit || 8;
	//this.readBuffer = new Buffer(3);
	this.readBuffer = new Buffer( Math.pow(2,this.bit).toString().length ); //forse per i 16bit, il valore max Ã¨ 4999 e non 65536
    this.listeners = [];
	
	initValues(this.bit);
	
    valuePath = this.pwmPath + 'value';
	if (fs.readFileSync(this.pwmPath + 'enable') == '0' ){
        // The pin hasn't been exported yet so export it.
        fs.writeFileSync(this.pwmPath + 'enable', '1');
		
        // Allow all users to read and write the GPIO value file
        fs.chmodSync(valuePath, 0666);
    } 
	
    this.valueFd = fs.openSync(valuePath, 'r+'); // Cache fd for performance.

}

exports.Pwm = Pwm;

function initValues(bit){
	var max = Math.pow(2, bit);
	for(i = 0; i < max; i++){
		values.push(new Buffer(i.toString()));
	}
}

function getValues(value){
	value = parseInt(value);
	switch(this.bit){
		case 8:
			value = value < 0 ? 0 : value;
			value = value > 255 ? 255 : value;
			return value;
		break;
		case 16:
			value = value < 0 ? 0 : value;
			value = value > 65536 ? 65536 : value;
			return value;
		break;
		default :
			value = value < 0 ? 0 : value;
			value = value > 255 ? 255 : value;
			return value;
	}
}


Pwm.prototype.watch = function(callback) {
    var events;
	this.listeners.push(callback);
	var that = this;
	var old_value, new_value;
	if(this.listeners.length == 1 ){
		new_value = that.readSync();
		old_value = new_value;
		var timer = setInterval(function(){
				callbacks = that.listeners.slice(0);
				if(callbacks.length > 0){
					new_value = that.readSync();
					if( new_value <= (old_value - that.resolution) || //risoluzione dell'informazione
						new_value >= (old_value + that.resolution) ){
						old_value = new_value;
						callbacks.forEach(function (callback) {
							callback(null, new_value);
						});
					}
				}
		},this.sampling);//periodo di campionamento
	}
};

/**
 * Write PWM value synchronously.
 *
 * value: number // from 0 to 255
 */
Pwm.prototype.writeSync = function(value) {
	value = getValues(value);
    var writeBuffer = values[value];console.log(writeBuffer);
	fs.writeSync(this.valueFd, writeBuffer, 0, writeBuffer.length, 0);
	return value;
};

Pwm.prototype.write = function(value, callback) {
	value = getValues(value);
    var writeBuffer = values[value];
    fs.write(this.valueFd, writeBuffer, 0, writeBuffer.length, 0, callback(value));
};


/**
 * Read PWM value synchronously.
 *
 * Returns - number // from 0 to 255
 */
Pwm.prototype.readSync = function() {
    this.readBuffer.fill(0);//pulisco il buffer
	fs.readSync(this.valueFd, this.readBuffer, 0, 3, 0);
    //return this.readBuffer[0] === one[0] ? 1 : 0;
	return parseInt(decoder.write(this.readBuffer));
};

//TODO: read async


/**
 * Get PWM options.
 *
 * Returns - object // Must not be modified
 */
Pwm.prototype.options = function() {
    return this.opts;
};

/**
 * Reverse the effect of exporting the PWM to userspace. The Adc object
 * should not be used after calling this method.
 */
/*
Pwm.prototype.unexport = function(callback) {
    this.unwatchAll();
    fs.closeSync(this.valueFd);
    fs.writeFileSync(adcEnablingPath + 'enable', '0');
};
*/
/*
Pwm.prototype.isExported = function(){
	return fs.existsSync(this.adcPath);
}
*/